use image::{ImageBuffer, Rgb, RgbImage, imageops};
use qrcode::QrCode;
use crate::baserow::{BaserowClient, Storage};
use std::path::Path;
use std::collections::HashMap;

pub struct LabelGenerator {
    baserow_client: BaserowClient,
    baserow_base_url: String,
}

impl LabelGenerator {
    pub fn new(baserow_client: BaserowClient, baserow_base_url: String) -> Self {
        Self {
            baserow_client,
            baserow_base_url,
        }
    }

    pub fn generate_qr_code(&self, storage_id: u64, storage_table_id: u64, database_id: u64, storage_view_id: u64) -> Result<ImageBuffer<Rgb<u8>, Vec<u8>>, Box<dyn std::error::Error>> {
        let storage_url = format!("{}/database/{}/table/{}/{}/row/{}", 
            self.baserow_base_url.trim_end_matches('/'), 
            database_id,
            storage_table_id,
            storage_view_id,  // This is the view ID (e.g., 3153)
            storage_id
        );
        
        println!("Generating QR code for URL: {}", storage_url);
        
        let code = QrCode::new(&storage_url)?;
        
        // Get the QR code as a matrix of booleans
        let qr_matrix = code.to_colors();
        let module_count = (qr_matrix.len() as f64).sqrt() as usize;
        
        let target_size = 200u32;
        let module_size = target_size / module_count as u32;
        
        let mut rgb_image = ImageBuffer::new(target_size, target_size);
        
        // Fill with white background first
        for pixel in rgb_image.pixels_mut() {
            *pixel = Rgb([255, 255, 255]);
        }
        
        // Draw QR code modules
        for (i, &is_dark) in qr_matrix.iter().enumerate() {
            let module_x = i % module_count;
            let module_y = i / module_count;
            
            let start_x = module_x as u32 * module_size;
            let start_y = module_y as u32 * module_size;
            
            if is_dark == qrcode::Color::Dark {
                // Fill the module with black
                for y in start_y..(start_y + module_size).min(target_size) {
                    for x in start_x..(start_x + module_size).min(target_size) {
                        if x < target_size && y < target_size {
                            rgb_image.put_pixel(x, y, Rgb([0, 0, 0]));
                        }
                    }
                }
            }
        }
        
        Ok(rgb_image)
    }

    pub fn create_label(&self, storage: &Storage, storage_table_id: u64, database_id: u64, storage_view_id: u64) -> Result<RgbImage, Box<dyn std::error::Error>> {
        // Create a 600x300 pixel label
        let width = 600;
        let height = 300;
        let mut img = ImageBuffer::new(width, height);
        
        // Fill with white background
        for pixel in img.pixels_mut() {
            *pixel = Rgb([255, 255, 255]);
        }

        // Generate QR code (200x200)
        let qr_image = self.generate_qr_code(storage.id, storage_table_id, database_id, storage_view_id)?;
        
        // Position QR code on the right side of the label (380, 50)
        imageops::overlay(&mut img, &qr_image, 380, 50);
        
        // Add storage name and ID text
        let storage_name = storage.get_name().unwrap_or_else(|| format!("Storage {}", storage.id));
        let storage_id_text = format!("ID: {}", storage.id);
        
        // Draw storage name (larger, centered)
        self.draw_text(&mut img, &storage_name, 50, 80)?;
        
        // Draw storage ID below the name
        self.draw_text(&mut img, &storage_id_text, 50, 140)?;
        
        Ok(img)
    }

    fn draw_text(&self, img: &mut RgbImage, text: &str, x: u32, y: u32) -> Result<(), Box<dyn std::error::Error>> {
        // Use a simple embedded font data for basic text rendering
        // This is a minimal font implementation for the label
        
        let text_color = Rgb([0, 0, 0]); // Black text
        
        // Simple bitmap font - each character is 8x12 pixels
        let font_data = self.get_simple_font_data();
        
        for (i, ch) in text.chars().enumerate() {
            if i > 25 { break; } // Limit text length
            
            let char_x = x + (i as u32 * 10); // 8 pixels width + 2 spacing
            
            if let Some(char_bitmap) = font_data.get(&ch) {
                for (row, &byte) in char_bitmap.iter().enumerate() {
                    for bit in 0..8 {
                        if (byte >> (7 - bit)) & 1 == 1 {
                            let px = char_x + bit;
                            let py = y + row as u32;
                            if px < img.width() && py < img.height() {
                                img.put_pixel(px, py, text_color);
                            }
                        }
                    }
                }
            } else {
                // Draw a simple rectangle for unknown characters
                for dx in 0..8 {
                    for dy in 0..12 {
                        let px = char_x + dx;
                        let py = y + dy;
                        if px < img.width() && py < img.height() && (dx == 0 || dx == 7 || dy == 0 || dy == 11) {
                            img.put_pixel(px, py, text_color);
                        }
                    }
                }
            }
        }
        
        Ok(())
    }

    fn get_simple_font_data(&self) -> HashMap<char, Vec<u8>> {
        let mut font = HashMap::new();
        
        // Simple 8x12 bitmap font for basic characters
        font.insert('A', vec![0x00, 0x18, 0x24, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00]);
        font.insert('B', vec![0x00, 0x7C, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00]);
        font.insert('C', vec![0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('D', vec![0x00, 0x78, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00]);
        font.insert('E', vec![0x00, 0x7E, 0x40, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00]);
        font.insert('F', vec![0x00, 0x7E, 0x40, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00]);
        font.insert('G', vec![0x00, 0x3C, 0x42, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x46, 0x3A, 0x00, 0x00]);
        font.insert('H', vec![0x00, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00]);
        font.insert('I', vec![0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00]);
        font.insert('J', vec![0x00, 0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00, 0x00]);
        font.insert('K', vec![0x00, 0x42, 0x44, 0x48, 0x50, 0x60, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00]);
        font.insert('L', vec![0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00]);
        font.insert('M', vec![0x00, 0x42, 0x66, 0x5A, 0x5A, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00]);
        font.insert('N', vec![0x00, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00]);
        font.insert('O', vec![0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('P', vec![0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00]);
        font.insert('Q', vec![0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x52, 0x4A, 0x44, 0x3A, 0x00, 0x00]);
        font.insert('R', vec![0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x48, 0x44, 0x42, 0x42, 0x00, 0x00]);
        font.insert('S', vec![0x00, 0x3C, 0x42, 0x40, 0x30, 0x0C, 0x02, 0x42, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('T', vec![0x00, 0x7F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00]);
        font.insert('U', vec![0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('V', vec![0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x18, 0x00, 0x00]);
        font.insert('W', vec![0x00, 0x42, 0x42, 0x42, 0x42, 0x5A, 0x5A, 0x66, 0x42, 0x42, 0x00, 0x00]);
        font.insert('X', vec![0x00, 0x42, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x42, 0x42, 0x00, 0x00]);
        font.insert('Y', vec![0x00, 0x41, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00]);
        font.insert('Z', vec![0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40, 0x7E, 0x00, 0x00]);
        
        // Numbers
        font.insert('0', vec![0x00, 0x3C, 0x42, 0x46, 0x4A, 0x52, 0x62, 0x42, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('1', vec![0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00]);
        font.insert('2', vec![0x00, 0x3C, 0x42, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00]);
        font.insert('3', vec![0x00, 0x3C, 0x42, 0x02, 0x0C, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('4', vec![0x00, 0x04, 0x0C, 0x14, 0x24, 0x44, 0x7E, 0x04, 0x04, 0x04, 0x00, 0x00]);
        font.insert('5', vec![0x00, 0x7E, 0x40, 0x40, 0x7C, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('6', vec![0x00, 0x1C, 0x20, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('7', vec![0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00]);
        font.insert('8', vec![0x00, 0x3C, 0x42, 0x42, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('9', vec![0x00, 0x3C, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x04, 0x08, 0x70, 0x00, 0x00]);
        
        // Lowercase letters (smaller versions)
        font.insert('a', vec![0x00, 0x00, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x46, 0x3A, 0x00, 0x00]);
        font.insert('b', vec![0x00, 0x40, 0x40, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x62, 0x5C, 0x00, 0x00]);
        font.insert('c', vec![0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('d', vec![0x00, 0x02, 0x02, 0x3A, 0x46, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x00, 0x00]);
        font.insert('e', vec![0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('f', vec![0x00, 0x0E, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00]);
        font.insert('g', vec![0x00, 0x00, 0x00, 0x3A, 0x46, 0x42, 0x42, 0x46, 0x3A, 0x02, 0x42, 0x3C]);
        font.insert('h', vec![0x00, 0x40, 0x40, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00]);
        font.insert('i', vec![0x00, 0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00]);
        font.insert('j', vec![0x00, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00]);
        font.insert('k', vec![0x00, 0x40, 0x40, 0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00]);
        font.insert('l', vec![0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00]);
        font.insert('m', vec![0x00, 0x00, 0x00, 0x76, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x00, 0x00]);
        font.insert('n', vec![0x00, 0x00, 0x00, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00]);
        font.insert('o', vec![0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('p', vec![0x00, 0x00, 0x00, 0x5C, 0x62, 0x42, 0x42, 0x62, 0x5C, 0x40, 0x40, 0x40]);
        font.insert('q', vec![0x00, 0x00, 0x00, 0x3A, 0x46, 0x42, 0x42, 0x46, 0x3A, 0x02, 0x02, 0x02]);
        font.insert('r', vec![0x00, 0x00, 0x00, 0x5C, 0x62, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00]);
        font.insert('s', vec![0x00, 0x00, 0x00, 0x3C, 0x42, 0x30, 0x0C, 0x02, 0x42, 0x3C, 0x00, 0x00]);
        font.insert('t', vec![0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0E, 0x00, 0x00]);
        font.insert('u', vec![0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x00, 0x00]);
        font.insert('v', vec![0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x18, 0x00, 0x00]);
        font.insert('w', vec![0x00, 0x00, 0x00, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00]);
        font.insert('x', vec![0x00, 0x00, 0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x42, 0x00, 0x00]);
        font.insert('y', vec![0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x02, 0x42, 0x3C]);
        font.insert('z', vec![0x00, 0x00, 0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00]);
        
        // Common symbols
        font.insert(' ', vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        font.insert('-', vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        font.insert('_', vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00]);
        font.insert('.', vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00]);
        font.insert(':', vec![0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00]);
        font.insert('/', vec![0x00, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00]);
        
        font
    }

    pub async fn generate_label_by_id(&self, storage_id: u64, storage_table_id: u64, database_id: u64, storage_view_id: u64, output_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        println!("Looking up storage by ID: {}", storage_id);
        
        let storage = self.baserow_client.find_storage_by_id(storage_id).await?
            .ok_or_else(|| format!("Storage with ID {} not found", storage_id))?;
        
        let storage_name = storage.get_name().unwrap_or_else(|| format!("Storage {}", storage.id));
        println!("Found storage: {}", storage_name);
        
        let label_image = self.create_label(&storage, storage_table_id, database_id, storage_view_id)?;
        label_image.save(output_path)?;
        
        println!("Label generated for storage '{}' (ID: {}) -> {}", 
                 storage_name, storage.id, output_path.display());
        
        Ok(())
    }

    pub async fn generate_label_by_name(&self, storage_name: &str, storage_table_id: u64, database_id: u64, storage_view_id: u64, output_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        println!("Looking up storage by name: {}", storage_name);
        
        let storage = self.baserow_client.find_storage_by_name(storage_name).await?
            .ok_or_else(|| format!("Storage with name '{}' not found", storage_name))?;
        
        let found_name = storage.get_name().unwrap_or_else(|| format!("Storage {}", storage.id));
        println!("Found storage: {} (ID: {})", found_name, storage.id);
        
        let label_image = self.create_label(&storage, storage_table_id, database_id, storage_view_id)?;
        label_image.save(output_path)?;
        
        println!("Label generated for storage '{}' (ID: {}) -> {}", 
                 found_name, storage.id, output_path.display());
        
        Ok(())
    }
}